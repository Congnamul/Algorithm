# 입력
# N: 남은 기간 (1 ≤ N ≤ 200)
# M: 챕터의 수 (1 ≤ M ≤ 20)
N, M = map(int, input().split())

# 각 챕터의 소요 시간과 페이지 데이터를 저장
# 예: [(3, 10), (5, 20), ...]
book = [list(map(int, input().split())) for _ in range(M)]

# DP 배열 초기화
# dp[i]: i일 남았을 때 읽을 수 있는 최대 페이지 수
# 초기값은 0으로 설정 (아무것도 읽지 않았을 때 최대 페이지 수는 0)
dp = [0] * (N + 1)

# DP 진행
# 각 챕터를 하나씩 고려하여 최적해 계산
for time, pages in book:
    # 시간을 거꾸로 탐색
    # 거꾸로 탐색하지 않으면 dp[t-time]이 갱신된 값을 참조하게 되어 잘못된 계산이 될 수 있음
    # 따라서 dp[t]는 항상 이전 값들을 기반으로 갱신되도록 보장
    for t in range(N, time - 1, -1):
        # 점화식: 현재 상태와 현재 챕터를 포함했을 때의 최대값 중 더 큰 값을 선택
        # dp[t]: 현재 남은 t일에서의 최대 페이지 수
        # dp[t - time] + pages: 현재 챕터를 읽었을 때의 최대 페이지 수
        dp[t] = max(dp[t], dp[t - time] + pages)

# 결과 출력
# dp[N]: 목표한 N일 남았을 때의 읽을 수 있는 최대 페이지 수
print(dp[N])
